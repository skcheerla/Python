Control structures in Python determine the flow of program execution. They allow you to make decisions, repeat actions, and control how your code runs.

## Conditional Statements

### if, elif, else

```python
age = 18

if age >= 18:
    print("You can vote")
elif age >= 16:
    print("You can get a learner's permit")
else:
    print("You're too young")
```

### Conditional Expressions (Ternary Operator)

```python
status = "adult" if age >= 18 else "minor"
```

### match Statement (Python 3.10+)

```python
day = "monday"

match day:
    case "monday" | "tuesday" | "wednesday" | "thursday" | "friday":
        print("Weekday")
    case "saturday" | "sunday":
        print("Weekend")
    case _:
        print("Invalid day")
```

## Loops

### for Loop

Iterate over sequences (lists, strings, ranges):

```python
# Loop through a list
fruits = ["apple", "banana", "orange"]
for fruit in fruits:
    print(fruit)

# Loop through a range
for i in range(5):
    print(i)  # prints 0, 1, 2, 3, 4

# Loop through a string
for char in "hello":
    print(char)

# Loop with index
for i, fruit in enumerate(fruits):
    print(f"{i}: {fruit}")
```

### while Loop

Repeat while a condition is true:

```python
count = 0
while count < 5:
    print(count)
    count += 1

# Infinite loop (use with caution)
while True:
    user_input = input("Enter 'quit' to exit: ")
    if user_input == 'quit':
        break
```

## Loop Control Statements

### break
Exits the loop immediately:

```python
for i in range(10):
    if i == 5:
        break
    print(i)  # prints 0, 1, 2, 3, 4
```

### continue
Skips the rest of the current iteration:

```python
for i in range(5):
    if i == 2:
        continue
    print(i)  # prints 0, 1, 3, 4
```

### else with Loops
Executes when loop completes normally (not broken):

```python
for i in range(3):
    print(i)
else:
    print("Loop completed normally")
```

## Exception Handling

### try, except, else, finally

```python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
except ValueError:
    print("Invalid input - not a number")
except ZeroDivisionError:
    print("Cannot divide by zero")
else:
    print(f"Result: {result}")
finally:
    print("This always runs")
```

### raise
Manually raise exceptions:

```python
def validate_age(age):
    if age < 0:
        raise ValueError("Age cannot be negative")
    return age
```

## Nested Control Structures

```python
for i in range(3):
    for j in range(3):
        if i == j:
            continue
        print(f"({i}, {j})")
```

## List Comprehensions

Compact way to create lists with conditions:

```python
# Basic list comprehension
squares = [x**2 for x in range(10)]

# With condition
even_squares = [x**2 for x in range(10) if x % 2 == 0]

# Nested comprehension
matrix = [[i+j for j in range(3)] for i in range(3)]
```

### Exaplanation for matrix:

This is a concise way to create a matrix (a list of lists) in Python using a nested list comprehension. Let's break it down:

`matrix = [[i+j for j in range(3)] for i in range(3)]`

**1. Outer List Comprehension: `[... for i in range(3)]`**

  * `range(3)`: This generates a sequence of numbers: 0, 1, 2.
  * `for i in range(3)`: This means the code inside the outer square brackets will execute three times, with `i` taking on the values 0, then 1, then 2.
  * The result of this outer loop will be a list containing three elements. Each of these elements will be generated by the inner list comprehension.

**2. Inner List Comprehension: `[i+j for j in range(3)]`**

  * This part is executed for each value of `i` from the outer loop.
  * `range(3)`: Again, this generates 0, 1, 2 for `j`.
  * `for j in range(3)`: This means for each `i`, the code `i+j` will be evaluated three times, with `j` taking on values 0, 1, 2.
  * `i+j`: This is the expression that calculates the value for each element in the inner list.

**Let's trace the execution:**

  * **When `i = 0` (first iteration of the outer loop):**

      * Inner comprehension: `[0+j for j in range(3)]`
      * This evaluates to: `[0+0, 0+1, 0+2]` which is `[0, 1, 2]`
      * So, the first sublist in `matrix` is `[0, 1, 2]`.

  * **When `i = 1` (second iteration of the outer loop):**

      * Inner comprehension: `[1+j for j in range(3)]`
      * This evaluates to: `[1+0, 1+1, 1+2]` which is `[1, 2, 3]`
      * So, the second sublist in `matrix` is `[1, 2, 3]`.

  * **When `i = 2` (third iteration of the outer loop):**

      * Inner comprehension: `[2+j for j in range(3)]`
      * This evaluates to: `[2+0, 2+1, 2+2]` which is `[2, 3, 4]`
      * So, the third sublist in `matrix` is `[2, 3, 4]`.

**Output:**

When `print(matrix)` is executed, it will display:

```
[[0, 1, 2], [1, 2, 3], [2, 3, 4]]
```

This code effectively creates a 3x3 matrix where each element `(row, column)` is the sum of its row index and column index.

## Best Practices

- Use meaningful variable names in loops
- Avoid deeply nested structures when possible
- Use `enumerate()` when you need both index and value
- Consider list comprehensions for simple transformations
- Handle exceptions appropriately - don't use bare `except:`
- Use `else` clauses with loops when it makes code clearer

These control structures give you the power to create complex program logic and handle different scenarios in your Python applications.
